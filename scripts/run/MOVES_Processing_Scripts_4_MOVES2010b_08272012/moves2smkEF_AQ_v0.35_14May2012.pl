#!/usr/bin/perl
#
# Filename   : moves2smkEF_v0.35.pl
# Author     : Michele Jimenez, ENVIRON International Corp.
# Version    : 0.35
# Description: Generate SMOKE input Emission Factor Lookup Tables
#            : from MOVES2010b MySQL tables - use ONLY for MOVES2010b or later
#
#  Usage: moves2smkEF.pl [--output expanded|consolidated|all] [-u mysql_userid] [-p mysql_password] [-r RPD|RPV|PP] InputDBlist OutputPath(optional)\n";
#  		where
#		mysql_userid - mysql user that has write permissions for the MOVES database
#		mysql_password - password for mysql user (if needed)
#		RPD|RPP|RPV - process that you want to generate EF tables for, if not specified will generate all 3	
#  		InputDBlist - List of MySQL database names to process (generated by runspec_generator_v0.1.pl
#                             MOVES preprocessor)
#  		OutputPath - optional, if specified it overrides the output path specified in InputDBlist
#
#  Update log: 
#  MJimenez 16 june 2010 v0.13 Corrected typo in ratepervehicle PM calculation INSERT
#  UNC      ?? june 2010 v0.12 Generate additional output file of list of output SMOKE files and generate separate
#                              output emission factor tables by representative county and month.
#  MJimenez 05 july 2010 v0.13 implemented PM calculation correction outlined in 
#                              MOVES2010 PM25 Onroad Speciation method_4jun2010.doc
#
#  UNC      18 Aug  2010 v0.20 Removed SCC mapping part. MOVES2010a has an option to output SCC.
#                              Updated script to handle the MOVES2010a output tables with SCC
#  UNC      26 Sept 2010 v0.21 Add check for SCC column in rateper* tables with friendly error message
#  UNC      26 Sept 2010 v0.22 Fix FIPS and month substrings to correctly handle single digit state codes
#  UNC      26 Dec  2010 v0.23 Renamed evaporative permeation process to EPM; 
#                              fixed minor discrepancy in rate-per-vehicle output sort by emission process
#  UNC      06 Feb  2011 v0.24 Added option to call smkEFsum script to create consolidated output files
#  UNC      18 Feb  2011 v0.25 Fix RPD duplicate temperature handling to account for different temperature 
#                              sets per month; fix MRCLIST creation to work with multiple databases
#  UNC      04 Mar  2011 v0.26 Bug fix: Set NH4 to Zero to avoid negative POC/underestimating POC.
#                              Set NH4 to zero approach is proposed by EPA
#  UNC      09 Mar  2011 v0.27 Added HONO equations based on NO and NO2. Used the arrays that is originally
#                              designed for NH4 to output HONO estimates
#  UNC      16 Mar  2011 v0.30 Replacing incorrect rate-per-vehicle EXT and CEI EFs with
#                              US EPA generated national scale factors
#  UNC      21 Mar  2011 v0.30 Replacing missing SCCRoadType EFs from rateperdistance that were not in the 
#                              reference county
#  CSC      19 Jul 2011  v0.32 Added PMC calculations for BRK and TIR modes.  Automatically create NUM_TEMP_BIN
#                              header in output file.
#  CSC      01 Aug 2011  v0.32 Added command line specifications for mysql user override and running single types
#  CSC      30 Mar 2012  v0.33 Made the following changes for support of MOVES2010b:
#                              1) updated list of pollutants in INIT_SmokePolls based on MOVES2010bpollutants.xlsx,
#                                 including HONO, mercury, and a few other HAPs
#                              2) Passed through pollutantIDs 33 and 34 as NO2 and HONO, respectively, rather than
#                                 recalculate NO2 and HONO
#                              3) Commented out the section that removes/replaces extended idle emissions, because
#                                 starting with MOVES2010b this step is no longer needed
#  CSC      09 May 2012 v0.34  Added command line options and export sections for separate RPD and RPV refueling processes.
#  CSC      14 May 2012 v0.35  Removed RPDrf and RPVrf options, will be implicit in RPD and RPV options.
#
# CSC: 09 May 2012 - Added -c option, which combines the refueling processes with the rest of the RPD and RPV EF files.
# The default is to have separate RPD and RPV refueling EF files.
#  NOTE: This script should be used with MOVES2010b ONLY. For prior versions of MOVES, use the v0.32 version of this script.
#
#  <ASSUMPTION> are demarcated within the code
#  <HARDCODE>  are demarcated within the code
#======================================================================================================================
#	<ASSUMPTION> - user has read/write/delete/create table and schema rights in mySQL
#======================================================================================================================
#= MOVES to SMOKE Emission Factor Tables - a MOVES preprocessor utility
#=
#= Copyright (C) 2010 ENVIRON International Corporation
#=
#= The Runspec Generator is free software; you can redistribute it 
#= and/or modify it under the terms of the GNU General Public License
#= as published by the Free Software Foundation; either version 3
#= of the License, or (at your option) any later version.
#=
#= This utility is distributed in the hope that it will be useful,
#= but WITHOUT ANY WARRANTY; without even the implied warranty of
#= MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#= GNU General Public License for more details.
#=
#= You should have received a copy of the GNU General Public License
#= along with this program.  If not, see <http://www.gnu.org/licenses/>.
#=======================================================================

# --- variable declarations
use strict;
use DBI;
use FileHandle;
use Getopt::Long;

my ($outputType, $dbFile, $outDir, $outfile, $listfile, $hostname, $host, $lt);
my $userid = '';
my $passwd = '';
my $runType = '';
my $refuel = 0;
my ($db, $connectionInfo, $dbh, $sql, $sth, $sth2, $sql2, $sql3, $sqlX, $sqlX_2, $sthx, @data, @dataX);
my ($inputDB);
my ($debug,$len,$tmpstr);

# for PM calculations
my ($MOVESScenarioID, $yearID, $monthID, $dayID, $hourID, $FIPS, $pollID);
my ($SCCsmoke, $processID, $avgSpdBin, $temp, $relHum, $PM25OM, $PM25EC, $PM25SO4, $PM10BRAKE, $PM25BRAKE, $PM10TIRE, $PM25TIRE);
my ($PNO3, $METAL, $NH4, $POC, $PMFINE, $PMC, $NO, $NO2);
my ($FEC, $FNO3, $FMETAL, $Ratio, @pm_array, @pm_newIDs,$i, $sum);

# for output files
my ($csv_terminated, $csv_separator, $csv_enclosed, $csv_escaped, $fldlist, $fldstr, $rowout);

my (%pollSmoke, %procSmoke);
INIT_SmokePolls();
INIT_SmokeProcess();
#================================================================================================

# --- check arguments

$outputType = 'expanded';
GetOptions('output=s' => \$outputType, 'user|u:s' => \$userid, 'pass|p:s' => \$passwd, 'runtype|r:s' => \$runType, 'combine_rf|c' => \$refuel);
if ('consolidated' =~ /^$outputType/)
{
	$outputType = 'consolidated';
}
elsif ('all' =~ /^$outputType/)
{
	$outputType = 'all';
}
else
{
	$outputType = 'expanded';
}

# Check for valid run types
if ($runType ne '' && 'RPD' !~ /$runType/ && 'RPV' !~ /$runType/ && 'RPP' !~ /$runType/) 
{
	die "Please specify a valid type after '-r': RPD, RPV, or RPP.  To run all five do not use '-r' argument.\n";
}

($#ARGV >= 0) or die "Usage: $0 [--output expanded|consolidated|all] [-u <mysql userid>] [-p <mysql password>] [-r RPD|RPV|RPP] [-c] <InputDBlist> [<OutputPath>]\n";

$dbFile = $ARGV[0];
$outDir = "";
$outDir = $ARGV[1] if ($#ARGV == 1);

#================================================================================================
#  --- initialize ---
#
#  new PM2.5 speciated output pollutant IDs
#  <HARDCODE> - dummy integer pollutant IDs for PM2.5 speciation requirement
$pm_newIDs[0] = 9118;  #PNO3
$pm_newIDs[1] = 9119;  #METAL
$pm_newIDs[2] = 9120;  #NH4
$pm_newIDs[3] = 9121;  #POC
$pm_newIDs[4] = 9122;  #PMFINE
$pm_newIDs[5] = 9123;  #PMC
#$pm_newIDs[6] = 9124;  #NO2  # 30Mar2012: no longer needed, NO2 from pollutantID 33 is passed through directly
#$pm_newIDs[7] = 9125;  #HONO # 30Mar2012: no longer needed, HONO from pollutantID 34 is passed through directly

#  --- turn debug off, deletes all temporary tables (default)
$debug = 0;

#  --- for output csv formatted files
$csv_terminated = "\n";
$csv_separator = ",";
$csv_enclosed = '"';
$csv_escaped = "\\";

#================================================================================================

# --- open file of list of DBs to process, generated from the MOVES Driver Script preprocessor 
# <ASSUMPTION> - userid and password are null

open(DBLISTFILE, "$dbFile") or die "Unable to open input file of database names: $dbFile\n";

$_ = <DBLISTFILE>;
chomp($_);
if (uc trim($_) eq "DEBUG")  
{
	$debug = 1;
	$hostname = <DBLISTFILE>;
	chomp($hostname);
}
else
{
	$hostname = $_;
}

$_ = <DBLISTFILE>;
chomp($_);
$outDir = $_ if ($outDir eq "");
replace_slash();

if ( substr($outDir, length($outDir) - 1, 1) ne "/" )
{
	$outDir = $outDir . "/";
}

# --- database information
$host=$hostname;


#================================================================================================
my ($count, $calYear, $fips_use, $MOVES_DB_used);
$count = 1;
while (<DBLISTFILE>)
{
#	--- make connection to database

	$db=$_;      
	chomp($db);
	$connectionInfo="dbi:mysql:$db;$host";

	$dbh = DBI->connect($connectionInfo,$userid,$passwd) or die "Database connection not made\n";

	$lt = localtime;
	printf "\n%s Processing database %s...\n\n",$lt,$db;

#	-- get a corresponding input database name 
	$sql = " SELECT defaultDatabaseUsed, domainCountyID, domainDatabaseName from movesrun limit 1";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	if (@data = $sth->fetchrow_array())
	{
		$MOVES_DB_used = $data[0];
		$fips_use = $data[1];
		$inputDB = $data[2];
		$calYear = substr($data[2],9,4);
	}
	
#       -- check that emission factor tables have SCC column
        for my $table ('rateperdistance', 'rateperprofile', 'ratepervehicle') {
                $sth = $dbh->prepare("LISTFIELDS $table");
	        $sth->execute() or die "Error executing query: " . $sth->errstr;
	        unless ($sth->{'NAME_lc_hash'}{'scc'}) { 
	                die "Missing SCC column in database $db, table $table\n"
	        };
	}
	
#                                                          ========================================
#  -- Set up tables for all runs --- create a new schema MOVESPostProc to store a set of tables ---
#  --                                that will be referenced by all DBs in batch file           ---
#  --                                These are a pared down version of the default MOVES DB     ---
	if ( $count == 1 ) {

		++$count;

		$sql = "DROP DATABASE IF EXISTS MOVESPostProc";
		$sth = $dbh->prepare($sql);
		$sth->execute();

		$sql = "CREATE SCHEMA MOVESPostProc";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE TABLE MOVESPostProc.smokeProcess \
			SELECT processID, processName, shortName AS smokeProcID \
			FROM $MOVES_DB_used.emissionprocess";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		foreach $i (sort(keys(%procSmoke)))
		{
			$sql = "UPDATE MOVESPostProc.smokeProcess";
			$sql = $sql . " SET smokeProcID = '" . $procSmoke{$i} . "'";
			$sql = $sql . " WHERE processID = '" . $i . "'";

			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		}
	        $sql = "CREATE INDEX tmp_pid_idx1 ON MOVESPostProc.smokeProcess (processID);";
		$sth = $dbh->prepare($sql);
		$sth->execute();

		$lt = localtime;
		printf "  - Completed MOVESPostProc tables at %s\n",$lt;

	}  # end if, generate global tables in MOVESPostProc schema   ===========================

#================================================================================================
#	============= rate per distance table postprocessing =================================== RD
#================================================================================================


	$sql = "DROP TABLE IF EXISTS \
			RDpreX, \
			rateperdistance_smoke, \
			RVpreX, \
			ratepervehicle_smoke, \
			RPpreX, \
			rateperprofile_smoke, \
			rateperdistance_rf_smoke, \
			ratepervehicle_rf_smoke, \
			rateperdistance_short, \
			ratepervehicle_short, \
			temp_pollutants, \
			rateperdistance_shortorig";

	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - Completed drop tables at %s\n",$lt;

#       ==================================================================================
#	-- now lets get on to the rate per distance table --
#       ==================================================================================

	# Check the run type for either RPD or the default
	if ($runType eq "RPD" || $runType eq "") {

		printf "\n  Starting rate per distance processing...\n";

 		## Remove any existing mrclist
		unlink($outDir . "mrclist.rateperdistance.lst");

		my ($lastMonth, $monthPos, @monthStats, $whereClause);

#       --- we need to drop the hours with duplicate temperatures.  determine the condition
#       --- based on the distinct hours and temperatures
#       <ASSUMPTION> - the RD table has a different temperature bin for each hour, from min t at hour 0
#                      to max t.  If more than 24 temp bins then multiple MOVES runs will be made
		$sql = "SELECT DISTINCT hourID, temperature, monthID \
			FROM rateperdistance \
			WHERE SUBSTR(MOVESScenarioID,1,2) = 'RD' \
			ORDER BY monthID, temperature, hourID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		
		$lastMonth = 0;
		$monthPos = -1;
		while (@data = $sth->fetchrow_array())
		{
			if ( $data[2] != $lastMonth ) {
				$monthPos++;
				$lastMonth = $data[2];
				$monthStats[$monthPos]{'month'} = $lastMonth;
				$monthStats[$monthPos]{'recNo'} = 0;
				$monthStats[$monthPos]{'lastTemp'} = -999.;
				$monthStats[$monthPos]{'maxHr'} = 1;
			}
			$monthStats[$monthPos]{'recNo'}++;
			if ( $data[1] != $monthStats[$monthPos]{'lastTemp'} ) 
			{
				$monthStats[$monthPos]{'lastTemp'} = $data[1];
				$monthStats[$monthPos]{'maxHr'} = $data[0];
			}
		}

		$whereClause = " AND ( 0";
		for my $monthStat (@monthStats)
		{
			$whereClause .= " OR ( monthID = " . $monthStat->{'month'};
			if ( $monthStat->{'recNo'} == 24 )
			{
				$whereClause .= " AND hourID <= " . $monthStat->{'maxHr'};
			}
			else
			{
				$whereClause .= " AND temperature < " . $monthStat->{'lastTemp'} .
												" OR ( temperature = " . $monthStat->{'lastTemp'} . " AND hourID = " . $monthStat->{'maxHr'} . " )";
			}
			$whereClause .= " )";
		}
		$whereClause .= " )";
		
		#printf "\n  Starting rate per distance processing...\n";

		$sql = "CREATE TABLE rateperdistance_short \
			SELECT MOVESScenarioID, yearID, monthID, pollutantID, processID, SCC, \
			  avgSpeedBinID, temperature, relHumidity, \
			  CAST(IF(LENGTH(linkID)=9,SUBSTR(linkID,1,5),SUBSTR(linkID,1,4)) AS UNSIGNED INTEGER) AS FIPS, \
			  ratePerDistance \
			FROM rateperdistance WHERE SUBSTR(MOVESScenarioID,1,2) = 'RD'";
		$sql = $sql . $whereClause;
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$lt = localtime;
		printf "  - Created rateperdistance_short at %s\n",$lt;

#===========================================================================================================
# Replace missing emissions by road type
#===========================================================================================================

	    $sql = "UPDATE rateperdistance_short SET ratePerDistance = 0.0 WHERE ratePerDistance IS NULL";
	    $sth = $dbh->prepare($sql);
	    $sth->execute() or die "Error executing query: " . $sth->errstr;
		
		$sql = "ALTER TABLE rateperdistance_short ADD COLUMN roadTypeID INT";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		
		$sql = "UPDATE rateperdistance_short SET roadTypeID = SUBSTRING(SCC, 8, 2)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "ALTER TABLE rateperdistance_short ADD COLUMN masterKey CHAR(50)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		
		$sql = "UPDATE rateperdistance_short \
			SET masterKey = CONCAT_WS(',', monthID, pollutantID, processID, \
						  SUBSTRING(SCC, 1, 2), SUBSTRING(SCC, 3, 5), \
						  SUBSTRING(SCC, 10, 1), avgSpeedBinID, temperature)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE TABLE rateperdistance_shortorig SELECT * FROM rateperdistance_short";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE INDEX roadTypeID ON rateperdistance_short (roadTypeID)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE INDEX roadTypeID ON rateperdistance_shortorig (roadTypeID)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE INDEX masterKey ON rateperdistance_short (masterKey)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE INDEX masterKey ON rateperdistance_shortorig (masterKey)";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		
		my %roadReplaceIDs = (
		11 => [23, 25, 13],
		13 => [15, 17, 19, 21, 25],
		15 => [13, 17, 19, 21, 27],
		17 => [13, 15, 19, 21, 29],
		19 => [13, 15, 17, 21, 31],
		21 => [13, 15, 17, 19, 33],
		23 => [25, 11, 13],
		25 => [23, 11, 13],
		27 => [29, 31, 33, 15],
		29 => [27, 31, 33, 17],
		31 => [27, 29, 33, 19],
		33 => [27, 29, 31, 21]
		);
		
		for my $roadID (sort keys %roadReplaceIDs)
		{
			for my $replaceID (@{$roadReplaceIDs{$roadID}})
			{
				$sql = "UPDATE rateperdistance_short as a \
					SET a.ratePerDistance = \
					    (SELECT MIN(b.ratePerDistance) \
					     FROM rateperdistance_shortorig as b \
					     WHERE a.masterKey = b.masterKey \
					     AND b.roadTypeID = " . $replaceID . ") \
					WHERE a.roadTypeID = " . $roadID . " \
					AND a.ratePerDistance = 0.0";
				$sth = $dbh->prepare($sql);
				$sth->execute() or die "Error executing query: " . $sth->errstr;
			}
		}

		$lt = localtime;
		printf "  - Replaced rate-per-distance emission factors at %s\n",$lt;

#	========================================================================================

		$sql = "CREATE TABLE RDpreX \
			SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.FIPS, r.pollutantID, \
				p.smokeProcID, r.avgSpeedBinID, r.temperature, r.relHumidity, \
				CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
				r.ratePerDistance AS EFfinal \
			FROM rateperdistance_short r \
			     JOIN MOVESPostProc.smokeProcess p ON  r.processID = p.processID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		$lt = localtime;
		printf "  - Completed RDpreX at %s\n",$lt;

#	Generate the PM pollutants.  =========================================================
#	<HARDCODE> (see subroutine Calc_PMs)
#	The PM calculations are taken from "Interim Approach to develop CMAQ PM2.5 species
#	from Partially-speciated MOVES2010 EXHAUST PM2.5" by Madeleine Strum, EPA 16 Mar 2010
#
#	First do a cross tab to get the PM pollutants of interest,
#	then compute new pollutants, and finally insert additional PM records into RD table
#
#       CSC 30 Mar 2012: Removed HONO and NO2 calculations, since we're now passing those pollutants through directly
#       Could remove NO/NO2 from the select statement and $data[..] definitions if we wanted to. Keeping them doesn't hurt anything
#	=======================================================================================

		$sql = "SELECT rd.MOVESScenarioID, rd.yearID, rd.monthID, \
				rd.FIPS, rd.SCCsmoke, rd.smokeProcID, rd.avgSpeedBinID, rd.temperature, rd.relHumidity, \
				SUM(CASE PollutantID WHEN 111 THEN EFfinal ELSE 0 END) AS PM25OM, \
				SUM(CASE PollutantID WHEN 112 THEN EFfinal ELSE 0 END) AS PM25EC, \
				SUM(CASE PollutantID WHEN 115 THEN EFfinal ELSE 0 END) AS PM25SO4, \
				SUM(CASE PollutantID WHEN 32 THEN EFfinal ELSE 0 END) AS NO, \
				SUM(CASE PollutantID WHEN 33 THEN EFfinal ELSE 0 END) AS NO2, \
				SUM(CASE PollutantID WHEN 106 THEN EFfinal ELSE 0 END) AS PM10BRAKE, \
				SUM(CASE PollutantID WHEN 116 THEN EFfinal ELSE 0 END) AS PM25BRAKE, \
				SUM(CASE PollutantID WHEN 107 THEN EFfinal ELSE 0 END) AS PM10TIRE, \
				SUM(CASE PollutantID WHEN 117 THEN EFfinal ELSE 0 END) AS PM25TIRE \
			FROM RDpreX rd \
			WHERE pollutantID IN (111, 112, 115, 32, 33, 106, 116, 107, 117) \
				AND smokeProcID IN ('EXR', 'EXS', 'CXR', 'CXS', 'CEI', 'EXT', 'BRK', 'TIR') \
			GROUP BY MOVESScenarioID, yearID, monthID, \
					FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		while (@data = $sth->fetchrow_array())
		{
			$MOVESScenarioID = $data[0];
			$yearID 	= $data[1];
			$monthID	= $data[2];
			$FIPS		= $data[3];
			$SCCsmoke	= $data[4];
			$processID	= $data[5];
			$avgSpdBin	= $data[6];
			$temp		= $data[7];
			$relHum		= $data[8];
			$PM25OM		= $data[9];
			$PM25EC		= $data[10];
			$PM25SO4	= $data[11];
			$NO     	= $data[12];
			$NO2    	= $data[13];
			$PM10BRAKE	= $data[14];
			$PM25BRAKE	= $data[15];
			$PM10TIRE	= $data[16];
			$PM25TIRE	= $data[17];

			Calc_PMs();
			
#			$pm_array[7] = 0.008 * $NO  + 0.008 * $NO2;    # HONO calc using org NO2
#			$pm_array[6] = 0.992 * $NO2 - 0.008 * $NO;     # Update org NO2 by subtracting 0.008*NO

#			for($i=0;$i<=7;++$i)
			for($i=0;$i<=5;++$i)  # CSC 30 Mar 2012: only go up to 5 because we don't recalculate NO2/HONO anymore
			{
				$sqlX = "INSERT INTO RDpreX \
						(MOVESScenarioID, yearID, monthID, FIPS, pollutantID, SCCsmoke, smokeProcID, \
						avgSpeedBinID, temperature, relHumidity, EFfinal) \
					VALUES ('$MOVESScenarioID', $yearID, $monthID, $FIPS, $pm_newIDs[$i], '$SCCsmoke', '$processID', \
						$avgSpdBin, $temp, $relHum, $pm_array[$i])";
		
				$sthx = $dbh->prepare($sqlX);
				$sthx->execute() or die "Error executing query: " . $sthx->errstr;
			}  # end of insert for loop

		} #  end of PM data record processing  ========================================
		$lt = localtime;
		printf "  - Completed PM calculations at %s\n",$lt;

#	--do final cross tab query; all pollutants output on a single record =============
#	==================================================================================

		$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
			FROM RDpreX \
			GROUP BY pollutantID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sqlX = "CREATE TABLE rateperdistance_smoke \
			SELECT MOVESScenarioID, yearID, monthID, \
				FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity";

		while  (@data = $sth->fetchrow_array())
		{		
			$pollID = $data[0];
			$sum	= $data[1];

			if (exists $pollSmoke{$pollID})
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
			}
			else
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS MOVES" . $pollID;
			}
		}

		# CSC 09 May 2012: If the refuel combine flag is set, then include the refuel processes, otherwise drop them and produce them separately 
		if ($refuel eq 1) {
			$sqlX_2 = " FROM RDpreX \
				GROUP BY MOVESScenarioID, yearID, monthID, \
					FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity \
				ORDER BY temperature ASC, SCCsmoke ASC, \
					field(smokeProcID,'EXR','CXR','EPM','EFV','EFL','BRK','TIR','RFV','RFS'), avgSpeedBinID ASC"; # CSC 09 May 2012: added RFV/RFS to ordering
		} else {
			$sqlX_2 = " FROM RDpreX \
				WHERE smokeProcID NOT IN ('RFV', 'RFS') \
				GROUP BY MOVESScenarioID, yearID, monthID, \
					FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity \
				ORDER BY temperature ASC, SCCsmoke ASC, \
					field(smokeProcID,'EXR','CXR','EPM','EFV','EFL','BRK','TIR'), avgSpeedBinID ASC";
		}

		$sqlX = $sqlX . $sqlX_2;
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		$lt = localtime;
		printf "  - Completed rateperdistance_SMOKE at %s\n",$lt;

	#	--- generate output files for each reference county and fuel month
		$listfile = $outDir . "mrclist.rateperdistance.lst";
		open(LISTFILE, ">>", $listfile) or die "Unable to open output list file: $listfile\n";

		$sqlX = "SELECT DISTINCT FIPS, monthID \
			FROM rateperdistance_smoke \
			ORDER BY FIPS, monthID";
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		
		while (@dataX = $sthx->fetchrow_array())
		{
	#		--- name and open the output file ---
			$outfile = "rateperdistance_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
			unlink($outDir . $outfile);
			open(OUTFILE, ">", $outDir . $outfile) or die "Unable to open output file: $listfile\n";

	#		--- generate the NUM_TEMP_BIN header ---
			$sql = "SELECT COUNT(DISTINCT(temperature)) FROM rateperdistance_smoke WHERE monthID = '" . $dataX[1] . "'";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while (@data = $sth->fetchrow_array())
			{
				$rowout = "NUM_TEMP_BIN " . $data[0] . "\n";
				print OUTFILE $rowout; 
			}
	       
	#	        --- generate the header line for output table ---
			$sql = "SHOW COLUMNS FROM rateperdistance_smoke";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		
			$fldstr = "";
			while  (@data = $sth->fetchrow_array())
			{
				$fldlist = "'" . $data[0] . "'" . $csv_separator;
				$fldstr .= $fldlist;
			}
			$sql2 = substr($fldstr,0,-1);
			$sql2 .= $csv_terminated;

	#		--- run the output query and write to the output file --- 
			$sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM rateperdistance_smoke \
				WHERE FIPS = '" . $dataX[0] . "' \
				AND monthID = '" . $dataX[1] . "'"; 
		
			$sth = $dbh->prepare($sql3);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while  (@data = $sth->fetchrow_array())
			{
				$rowout = join $csv_separator,@data;
				$rowout .= $csv_terminated;
				print OUTFILE $rowout;
			}
			close(OUTFILE);
			
			print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
		}
		close(LISTFILE);
		$lt = localtime;
		printf "  - Completed rateperdistance_SMOKE export at %s\n",$lt;
	} #End RPD runtype

#       Added export section for RPD refueling
#       CSC: 09 May 2012
#	--do final cross tab query; all pollutants output on a single record =============
#	==================================================================================
	# Check the run type for either RPD or the default

	if (($runType eq "RPD" && $refuel ne 1) || ($runType eq "" && $refuel ne 1)) {

		printf "\n  Starting rate per distance refueling processing...\n";

 		## Remove any existing mrclist
		unlink($outDir . "mrclist.rateperdistance_refueling.lst");

		$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
			FROM RDpreX \
			GROUP BY pollutantID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sqlX = "CREATE TABLE rateperdistance_rf_smoke \
			SELECT MOVESScenarioID, yearID, monthID, \
				FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity";

		while  (@data = $sth->fetchrow_array())
		{		
			$pollID = $data[0];
			$sum	= $data[1];

			if (exists $pollSmoke{$pollID})
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
			}
			else
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS MOVES" . $pollID;
			}
		}

		$sqlX_2 = " FROM RDpreX \
			WHERE smokeProcID IN ('RFV', 'RFS') \
			GROUP BY MOVESScenarioID, yearID, monthID, \
				FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity \
			ORDER BY temperature ASC, SCCsmoke ASC, \
				field(smokeProcID,'RFV','RFS'), avgSpeedBinID ASC";

		$sqlX = $sqlX . $sqlX_2;
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		$lt = localtime;
		printf "  - Completed rateperdistance_SMOKE refueling at %s\n",$lt;

	#	--- generate output files for each reference county and fuel month
		$listfile = $outDir . "mrclist.rateperdistance_refueling.lst";
		open(LISTFILE, ">>", $listfile) or die "Unable to open output list file: $listfile\n";

		$sqlX = "SELECT DISTINCT FIPS, monthID \
			FROM rateperdistance_rf_smoke \
			ORDER BY FIPS, monthID";
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		
		while (@dataX = $sthx->fetchrow_array())
		{
	#		--- name and open the output file ---
			$outfile = "rateperdistance_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . "_refueling.csv";
			unlink($outDir . $outfile);
			open(OUTFILE, ">", $outDir . $outfile) or die "Unable to open output file: $listfile\n";

	#		--- generate the NUM_TEMP_BIN header ---
			$sql = "SELECT COUNT(DISTINCT(temperature)) FROM rateperdistance_rf_smoke WHERE monthID = '" . $dataX[1] . "'";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while (@data = $sth->fetchrow_array())
			{
				$rowout = "NUM_TEMP_BIN " . $data[0] . "\n";
				print OUTFILE $rowout; 
			}
	       
	#	        --- generate the header line for output table ---
			$sql = "SHOW COLUMNS FROM rateperdistance_rf_smoke";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		
			$fldstr = "";
			while  (@data = $sth->fetchrow_array())
			{
				$fldlist = "'" . $data[0] . "'" . $csv_separator;
				$fldstr .= $fldlist;
			}
			$sql2 = substr($fldstr,0,-1);
			$sql2 .= $csv_terminated;

	#		--- run the output query and write to the output file --- 
			$sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM rateperdistance_rf_smoke \
				WHERE FIPS = '" . $dataX[0] . "' \
				AND monthID = '" . $dataX[1] . "'"; 
		
			$sth = $dbh->prepare($sql3);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while  (@data = $sth->fetchrow_array())
			{
				$rowout = join $csv_separator,@data;
				$rowout .= $csv_terminated;
				print OUTFILE $rowout;
			}
			close(OUTFILE);
			
			print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
		}
		close(LISTFILE);
		$lt = localtime;
		printf "  - Completed rateperdistance_SMOKE refueling export at %s\n",$lt;
	} #End RPD rf runtype


#================================================================================================
#	============= rate per vehicle table postprocessing =================================== RV
#================================================================================================

	# Check the run type for either RPV or the default
	if ($runType eq 'RPV' || $runType eq "") { 

		printf "\n  Starting rate per vehicle processing...\n";

 		## Remove any existing mrclist
		unlink($outDir . "mrclist.ratepervehicle.lst");

		$sql = "CREATE TABLE ratepervehicle_short \
			SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.dayID, r.hourID, r.zoneID, r.pollutantID, \
			       r.processID, r.temperature, r.SCC, r.ratePerVehicle \
			FROM ratepervehicle r \
			WHERE substr(r.MOVESScenarioID,1,2) = 'RV';";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		$lt = localtime;
		printf "  - Created ratepervehicle_short at %s\n",$lt;

#===========================================================================================================	
# Replacing older crank Ext Idle (CEI) and Ext. Idel Exhaust (EXT) with the national scale EXT anc CEI EFs estimated by US EPA on Mar 16, 2011
# replacement extended idle rates are in database and table natl_ei_2007.ei_ratepervehicle
# C. Allen commented this out, 28 Mar 2012, because starting with MOVES 2010b we no longer need to adjust extended idle emissions
#===========================================================================================================	

#		#-- delete any existing extended idle or crankcase-extended idle emissions
#
#		$sql = "DELETE FROM ratepervehicle_short WHERE processID IN (17,90)";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#		
#		$sql = "SELECT zoneID FROM ratepervehicle_short LIMIT 1";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#		my ($zoneID) = $sth->fetchrow_array;
#		
#		$sql = "SELECT yearID FROM ratepervehicle_short LIMIT 1";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#		my ($yearID) = $sth->fetchrow_array;
#		
#		#-- create temporary table with required pollutants
#
#		$sql = "CREATE TABLE temp_pollutants SELECT DISTINCT pollutantID FROM ratepervehicle_short";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#
#		$sqlX = "SELECT DISTINCT monthID FROM ratepervehicle_short ORDER BY monthID";
#		$sthx = $dbh->prepare($sqlX);
#		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
#		
#		while (@dataX = $sthx->fetchrow_array())
#		{
#
#		    #--- drop temperature table if it exists
#		    $sql = "DROP TABLE IF EXISTS temp_temps";
#		    $sth = $dbh->prepare($sql);
#		    $sth->execute() or die "Error executing query: " . $sth->errstr;
#
#			$sql = "CREATE TABLE temp_temps \
#				SELECT DISTINCT temperature \
#				FROM ratepervehicle_short \
#				WHERE monthID = " . $dataX[0];
#			$sth = $dbh->prepare($sql);
#			$sth->execute() or die "Error executing query: " . $sth->errstr;
#
#		    #--- drop yearID table if it exists
#		    $sql = "DROP TABLE IF EXISTS temp_year";
#		    $sth = $dbh->prepare($sql);
#		    $sth->execute() or die "Error executing query: " . $sth->errstr;
#			
#			$sql = "CREATE TABLE temp_year \
#				SELECT DISTINCT yearID \
#				FROM ratepervehicle_short \
#				WHERE monthID = " . $dataX[0];
#			$sth = $dbh->prepare($sql);
#			$sth->execute() or die "Error executing query: " . $sth->errstr;
#
#			#-- Use joins with temporary tables to select and insert appropriate rows from national default extended idle rates
#			
#			$sql = "INSERT INTO ratepervehicle_short \
#					    (MOVESScenarioID, yearID, monthID, dayID, hourID, zoneID, \
#					    pollutantID, processID, temperature, SCC, ratePerVehicle) \
#				SELECT '999' AS MOVESScenarioID, " . $yearID . " AS yearID, \
#				       " . $dataX[0] . " AS monthID, e.dayID, e.hourID, \
#				       " . $zoneID . " AS zoneID, e.pollutantID, e.processID, \
#				       t.temperature, e.SCC, e.ratePerVehicle \
#				FROM natl_ext_idle.ei_ratepervehicle AS e \
#				JOIN temp_temps AS t \
#				  ON t.temperature = e.temperature
#				JOIN temp_pollutants AS p \
#				  ON p.pollutantID = e.pollutantID
#				JOIN temp_year AS y \
#				  ON y.yearID = e.yearID";
#			$sth = $dbh->prepare($sql);
#			$sth->execute() or die "Error executing query: " . $sth->errstr;
#		}
#		
#		#-- Update MOVESScenarioID to match expected format
#		#-- should not impact SMOKE/MOVES runs but may be helpful to mark these for checking results
#			
#		$sql = "UPDATE ratepervehicle_short \
#			SET MOVESScenarioID = CONCAT('RV_', IF(LENGTH(zoneID)=6, SUBSTR(zoneID,1,5), CONCAT('0', SUBSTR(zoneID,1,4))), '_', yearID, '_', monthID, '_T', IF(temperature < 0, CONCAT('n', ABS(temperature)), temperature)) \
#			WHERE MOVESScenarioID = '999';";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#		
#		#-- delete temporary tables
#		
#		$sql = "DROP TABLE temp_temps, \
#				   temp_pollutants";
#		$sth = $dbh->prepare($sql);
#		$sth->execute() or die "Error executing query: " . $sth->errstr;
#
#		$lt = localtime;
#		printf "  - Replaced CEI and EXT emissions at %s\n",$lt;
#	
#	========================================================================================

		$sql = "CREATE TABLE RVpreX \
			SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.dayID, r.hourID, \
				IF(LENGTH(r.zoneID)=6,SUBSTR(r.zoneID,1,5),SUBSTR(r.zoneID,1,4)) as FIPS, \
				r.pollutantID, \
				p.smokeProcID, r.temperature, CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
				r.ratePerVehicle AS EFfinal \
			FROM ratepervehicle_short r \
			     JOIN MOVESPostProc.smokeProcess p ON r.processID = p.processID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		$lt = localtime;
		printf "  - Completed RVpreX at %s\n",$lt;

#	Generate the PM pollutants.  =========================================================
#	<HARDCODE> (see subroutine Calc_PMs)
#	The PM calculations. First do a cross tab to get the PM pollutants of interest,
#	then compute new pollutants, and finally insert additional PM records into RV table
#
#       CSC 30 Mar 2012: Removed HONO and NO2 calculations, since we're now passing those pollutants through directly
#       Could remove NO/NO2 from the select statement and $data[..] definitions, but will leave them in for now to 
#       reduce the chance of a problem
#	=======================================================================================

		$sql = "SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, \
				FIPS, SCCsmoke, smokeProcID, temperature, \
				SUM(CASE PollutantID WHEN 111 THEN EFfinal ELSE 0 END) AS PM25OM, \
				SUM(CASE PollutantID WHEN 112 THEN EFfinal ELSE 0 END) AS PM25EC, \
				SUM(CASE PollutantID WHEN 115 THEN EFfinal ELSE 0 END) AS PM25SO4, \
				SUM(CASE PollutantID WHEN 32 THEN EFfinal ELSE 0 END) AS NO, \
				SUM(CASE PollutantID WHEN 33 THEN EFfinal ELSE 0 END) AS NO2 \
			FROM RVpreX \
			WHERE pollutantID IN (111, 112, 115, 32, 33) \
				AND smokeProcID IN ('EXR', 'EXS', 'CXR', 'CXS', 'CEI', 'EXT') \
			GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, \
					FIPS, SCCsmoke, smokeProcID, temperature";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		while (@data = $sth->fetchrow_array())
		{
			$MOVESScenarioID = $data[0];
			$yearID 	= $data[1];
			$monthID	= $data[2];
			$dayID		= $data[3];
			$hourID		= $data[4];
			$FIPS		= $data[5];
			$SCCsmoke	= $data[6];
			$processID	= $data[7];
			$temp		= $data[8];
			$PM25OM		= $data[9];
			$PM25EC		= $data[10];
			$PM25SO4	= $data[11];
			$NO     	= $data[12];
			$NO2    	= $data[13];

			Calc_PMs();

#			$pm_array[7] = 0.008 * $NO  + 0.008 * $NO2;    # HONO calc using org NO2
#			$pm_array[6] = 0.992 * $NO2 - 0.008 * $NO;     # Update org NO2 by subtracting 0.008*NO

#			for($i=0;$i<=7;++$i)
			for($i=0;$i<=5;++$i) # CSC 30 Mar 2012: only go up to 5 because we don't recalculate NO2/HONO anymore
			{
				$sql = "INSERT INTO RVpreX \
						(MOVESScenarioID, yearID, monthID, dayID, hourID, \
						FIPS, pollutantID, SCCsmoke, smokeProcID, temperature, EFfinal) \
					VALUES ('$MOVESScenarioID', $yearID, $monthID, $dayID, $hourID, \
						$FIPS, $pm_newIDs[$i], '$SCCsmoke', '$processID', $temp, $pm_array[$i])";
				$sth2 = $dbh->prepare($sql);
				$sth2->execute() or die "Error executing query: " . $sth2->errstr;
			}  # end of insert for loop

		} #  end of PM data record processing  ========================================
		$lt = localtime;
		printf "  - Completed PM calculations at %s\n",$lt;

#	--rate per vehicle -- do final cross tab query; all pollutants output on a single record =============
#	======================================================================================================

		$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
			FROM RVpreX \
			GROUP BY pollutantID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sqlX = "CREATE TABLE ratepervehicle_smoke \
			SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature";

		while  (@data = $sth->fetchrow_array())
		{		
			$pollID = $data[0];
			$sum	= $data[1];

			if (exists $pollSmoke{$pollID})
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
			}
			else
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS MOVES" . $pollID;
			}
		}

		# CSC 09 May 2012: If the refuel combine flag is set, then include the refuel processes, otherwise drop them and produce them separately 
		if ($refuel eq 1) {
			$sqlX = $sqlX . " FROM RVpreX \
				GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature \
				ORDER BY temperature ASC, dayID ASC, SCCsmoke ASC, \
					field(smokeProcID,'EXS','CXS','EPM','EXT','EFL','CEI','RFV','RFS'), hourID ASC"; # CSC 09 May 2012: Added RFV and RFS to ordering
		} else {
			$sqlX = $sqlX . " FROM RVpreX WHERE smokeProcID NOT IN ('RFV', 'RFS') \
				GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature \
				ORDER BY temperature ASC, dayID ASC, SCCsmoke ASC, \
					field(smokeProcID,'EXS','CXS','EPM','EXT','EFL','CEI'), hourID ASC";
		}

		$sth = $dbh->prepare($sqlX);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$lt = localtime;
		printf "  - Completed ratepervehicle_SMOKE at %s\n",$lt;

	#	--- generate output files for each reference county and fuel month
		$listfile = $outDir . "mrclist.ratepervehicle.lst";
		open(LISTFILE, ">>", $listfile) or die "Unable to open output list file: $listfile\n";

		$sqlX = "SELECT DISTINCT FIPS, monthID \
			FROM ratepervehicle_smoke \
			ORDER BY FIPS, monthID";
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		
		while (@dataX = $sthx->fetchrow_array())
		{
	#		--- name and open the output file ---
			$outfile = "ratepervehicle_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
			unlink($outDir . $outfile);
			open(OUTFILE, ">", $outDir . $outfile) or die "Unable to open output file: $listfile\n";

	#		--- generate the NUM_TEMP_BIN header ---
			$sql = "SELECT COUNT(DISTINCT(temperature)) FROM ratepervehicle_smoke WHERE monthID = '" . $dataX[1] . "'";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while (@data = $sth->fetchrow_array())
			{
				$rowout = "NUM_TEMP_BIN " . $data[0] . "\n";
				print OUTFILE $rowout; 
			}

	#	        --- generate the header line for output table ---
			$sql = "SHOW COLUMNS FROM ratepervehicle_smoke";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		
			$fldstr = "";
			while  (@data = $sth->fetchrow_array())
			{
				$fldlist = "'" . $data[0] . "'" . $csv_separator;
				$fldstr .= $fldlist;
			}
			$sql2 = substr($fldstr,0,-1);
			$sql2 .= $csv_terminated;
		
			$sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM ratepervehicle_smoke \
				WHERE FIPS = '" . $dataX[0] . "' \
				AND monthID = '" . $dataX[1] . "'"; 
		
			$sth = $dbh->prepare($sql3);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		       
			while  (@data = $sth->fetchrow_array())
			{
				$rowout = join $csv_separator,@data;
				$rowout .= $csv_terminated;
				print OUTFILE $rowout;
			}
			close(OUTFILE);

			print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
		}
		close(LISTFILE);
		$lt = localtime;
		printf "  - Completed ratepervehicle_SMOKE export at %s\n",$lt;
	} # End RPV runtype

#	======================================================================================================
#       Added export section for RPV refueling
#       CSC: 09 May 2012
#	--rate per vehicle -- do final cross tab query; all pollutants output on a single record =============
#	==================================================================================
	# Check the run type for either RPV or the default

	if (($runType eq "RPV" && $refuel ne 1) || ($runType eq "" && $refuel ne 1)) {

		printf "\n  Starting rate per vehicle refueling processing...\n";

		## Remove any existing mrclist
		unlink($outDir . "mrclist.rateperprofile_refueling.lst");

		$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
			FROM RVpreX \
			GROUP BY pollutantID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sqlX = "CREATE TABLE ratepervehicle_rf_smoke \
			SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature";

		while  (@data = $sth->fetchrow_array())
		{		
			$pollID = $data[0];
			$sum	= $data[1];

			if (exists $pollSmoke{$pollID})
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
			}
			else
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS MOVES" . $pollID;
			}
		}

		$sqlX = $sqlX . " FROM RVpreX WHERE smokeProcID IN ('RFV', 'RFS') \
			GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature \
			ORDER BY temperature ASC, dayID ASC, SCCsmoke ASC, \
				field(smokeProcID,'RFV','RFS'), hourID ASC";

		$sth = $dbh->prepare($sqlX);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$lt = localtime;
		printf "  - Completed ratepervehicle_SMOKE refueling at %s\n",$lt;

	#	--- generate output files for each reference county and fuel month
		$listfile = $outDir . "mrclist.ratepervehicle_refueling.lst";
		open(LISTFILE, ">>", $listfile) or die "Unable to open output list file: $listfile\n";

		$sqlX = "SELECT DISTINCT FIPS, monthID \
			FROM ratepervehicle_rf_smoke \
			ORDER BY FIPS, monthID";
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		
		while (@dataX = $sthx->fetchrow_array())
		{
	#		--- name and open the output file ---
			$outfile = "ratepervehicle_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . "_refueling.csv";
			unlink($outDir . $outfile);
			open(OUTFILE, ">", $outDir . $outfile) or die "Unable to open output file: $listfile\n";

	#		--- generate the NUM_TEMP_BIN header ---
			$sql = "SELECT COUNT(DISTINCT(temperature)) FROM ratepervehicle_rf_smoke WHERE monthID = '" . $dataX[1] . "'";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while (@data = $sth->fetchrow_array())
			{
				$rowout = "NUM_TEMP_BIN " . $data[0] . "\n";
				print OUTFILE $rowout; 
			}

	#	        --- generate the header line for output table ---
			$sql = "SHOW COLUMNS FROM ratepervehicle_rf_smoke";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		
			$fldstr = "";
			while  (@data = $sth->fetchrow_array())
			{
				$fldlist = "'" . $data[0] . "'" . $csv_separator;
				$fldstr .= $fldlist;
			}
			$sql2 = substr($fldstr,0,-1);
			$sql2 .= $csv_terminated;
		
			$sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM ratepervehicle_rf_smoke \
				WHERE FIPS = '" . $dataX[0] . "' \
				AND monthID = '" . $dataX[1] . "'"; 
		
			$sth = $dbh->prepare($sql3);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		       
			while  (@data = $sth->fetchrow_array())
			{
				$rowout = join $csv_separator,@data;
				$rowout .= $csv_terminated;
				print OUTFILE $rowout;
			}
			close(OUTFILE);

			print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
		}
		close(LISTFILE);
		$lt = localtime;
		printf "  - Completed ratepervehicle_SMOKE refueling export at %s\n",$lt;
	} # End RPV_rf runtype

#================================================================================================
#	============= rate per profile table postprocessing =================================== RP
#================================================================================================

	# Check the run type for either RPP or the default
	if ($runType eq 'RPP' || $runType eq "") { 

		printf "\n  Starting rate per profile processing...\n";

 		## Remove any existing mrclist
		unlink($outDir . "mrclist.rateperprofile.lst");

		$sql = "CREATE TABLE RPpreX \
			SELECT r.MOVESScenarioID, r.yearID, \
				IF(LENGTH(r.temperatureProfileID)=10,substr(r.temperatureProfileID,7,2),substr(r.temperatureProfileID,6,2)) AS monthID, \
				r.dayID, r.hourID, \
				IF(LENGTH(r.temperatureProfileID)=10,substr(r.temperatureProfileID,1,5),substr(r.temperatureProfileID,1,4)) AS countyID, \
				r.pollutantID, \
				p.smokeProcID, r.temperature, CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
				r.ratePerVehicle AS EFfinal \
			FROM rateperprofile r \
			     JOIN MOVESPostProc.smokeProcess p ON r.processID = p.processID \
			WHERE substr(r.MOVESScenarioID,1,2) = 'RP'";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;
		$lt = localtime;
		printf "  - Completed RPpreX at %s\n",$lt;

#	-- Note - no PMs with rateperProfile records ---

#	--rate per profile -- do final cross tab query; all pollutants output on a single record =============
#	======================================================================================================

		$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
			FROM RPpreX \
			GROUP BY pollutantID";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sqlX = "CREATE TABLE rateperprofile_smoke \
			SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, countyID, SCCsmoke, smokeProcID, temperature";

		while  (@data = $sth->fetchrow_array())
		{		
			$pollID = $data[0];
			$sum	= $data[1];

			if (exists $pollSmoke{$pollID})
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
			}
			else
			{
				$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS MOVES" . $pollID;
			}
		}

		$sqlX = $sqlX . " FROM RPpreX \
			GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, countyID, SCCsmoke, smokeProcID, temperature \
			ORDER BY MOVESScenarioID ASC, dayID ASC, SCCsmoke ASC, hourID, temperature"; 
		$sth = $dbh->prepare($sqlX);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$lt = localtime;
		printf "  - Completed rateperprofile_SMOKE at %s\n",$lt;

	#	--- generate output files for each reference county and fuel month
		$listfile = $outDir . "mrclist.rateperprofile.lst";
		open(LISTFILE, ">>", $listfile) or die "Unable to open output list file: $listfile\n";

		$sqlX = "SELECT DISTINCT countyID, monthID \
			FROM rateperprofile_smoke \
			ORDER BY countyID, monthID";
		$sthx = $dbh->prepare($sqlX);
		$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		
		while (@dataX = $sthx->fetchrow_array())
		{
	#		--- name and open the output file ---
			$outfile = "rateperprofile_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
			unlink($outDir . $outfile);
			open(OUTFILE, ">", $outDir . $outfile) or die "Unable to open output file: $listfile\n";

	#		--- generate the NUM_TEMP_BIN header ---
			$sql = "SELECT COUNT(DISTINCT(MOVESScenarioID)) FROM rateperprofile_smoke WHERE monthID = '" . $dataX[1] . "'";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while (@data = $sth->fetchrow_array())
			{
				$rowout = "NUM_TEMP_BIN " . $data[0] . "\n";
				print OUTFILE $rowout; 
			}

	#	        --- generate the header line for output table ---
			$sql = "SHOW COLUMNS FROM rateperprofile_smoke";
			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		
			$fldstr = "";
			while  (@data = $sth->fetchrow_array())
			{
				$fldlist = "'" . $data[0] . "'" . $csv_separator;
				$fldstr .= $fldlist;
			}
			$sql2 = substr($fldstr,0,-1);
			$sql2 .= $csv_terminated;
		
			$sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM rateperprofile_smoke \
				WHERE countyID = '" . $dataX[0] . "' \
				AND monthID = '" . $dataX[1] . "'"; 
		
			$sth = $dbh->prepare($sql3);
			$sth->execute() or die "Error executing query: " . $sth->errstr;

			while  (@data = $sth->fetchrow_array())
			{
				$rowout = join $csv_separator,@data;
				$rowout .= $csv_terminated;
				print OUTFILE $rowout;
			}
			close(OUTFILE);

			print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
		}
		close(LISTFILE);
		$lt = localtime;
		printf "  - Completed rateperprofile_SMOKE export at %s\n",$lt;

	} #End RPP run type

#	======================================================================================================
#  --- delete all of the temporary tables in order to free up disk space ---
if ( $debug == 0 )
{
	$sql = "DROP TABLE IF EXISTS \
		RDpreX, \
		RVpreX, \
		RPpreX, \
		rateperdistance_short, \
		rateperdistance_shortorig, \
		ratepervehicle_short ";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
}

}  # end of processing ___ while, list of dbs

#	======================================================================================================
#  --- create consolidated output if requested ---
if ( $outputType eq 'consolidated' || $outputType eq 'all' )
{
	my $scriptName = 'smkEFsum_v0.23_14may2012.pl';
	print "\n  Running $scriptName to create consolidated output files at " . localtime() . "\n\n";
	print "runtype = $runType \n";
	my @scriptArgs = ($dbFile, $outDir);
	unshift (@scriptArgs, '--delete') if ($outputType eq 'consolidated');
	unshift (@scriptArgs, '--runtype ' . $runType) if ($runType ne "");
	unshift (@scriptArgs, '--combine_rf') if ($refuel eq 1);
	system("perl $scriptName @scriptArgs") == 0 or die "Could not run $scriptName: $?\n";
}

#================================================================================================
#  Subroutines
#================================================================================================

#  -- the PM calculation, similar for RD and RV tables ====================
#<HARDCODE> 	The PM calculations are taken from "Interim Approach to develop CMAQ PM2.5 species
#<HARDCODE>     from Partially-speciated MOVES2010 EXHAUST PM2.5" by Madeleine Strum, EPA 16 Mar 2010
#<HARDCODE>	07July2010 update per MStrum revisions dated June 4,2010
sub Calc_PMs
{
my ($PEC_Tadj, $maxtemp);
$maxtemp = 72.0;

		if (substr($SCCsmoke,0,4) eq "2201" ){
			$FEC = 20.80113619;
			$FNO3 = 0.1015;
			$FMETAL = 2.2256;
			$Ratio = 1.086;
		}
		elsif (substr($SCCsmoke,0,6) eq "223007") {
			$FEC = 77.1241;
			$FNO3 = 0.1141;
			$FMETAL = 0.2757;
			$Ratio = 1.0309;
		}
		elsif (substr($SCCsmoke,0,4) eq "2230") {
			$FEC = 57.48051203;
			$FNO3 = 0.23;
			$FMETAL = 0.6513;
			$Ratio = 1.0309;
		}
		else 	{
			die "ERROR:  No match for SMOKE SCC code PM conversion factors \n";
		}

#		MOVES cold temperature adjustment to gas vehicles
		$PEC_Tadj = 1.0;
		if (substr($SCCsmoke,0,4) eq "2201" )
                {
			if ($temp < $maxtemp )
			{

				if ( $processID eq "EXR" || $processID eq "CXR" ) {
					$PEC_Tadj = 9.871 * exp(-0.0318 * $temp);
				}
				else
				{
					$PEC_Tadj = 28.039 * exp(-0.0463 * $temp);
				}
			}
		}

		$PNO3 = ($PM25EC/$PEC_Tadj) * $FNO3 / $FEC;					

		$METAL = ($PM25EC/$PEC_Tadj) * $FMETAL / $FEC;					

# Bug on 03/04/2011		$NH4 = ($PNO3/62.0049 + 2 * $PM25SO4/96.0576) * 18.0383;
		$NH4 = 0.0;

		$POC = 5/6 * ($PM25OM - $METAL - $NH4 - $PNO3);		

		$PMFINE = $METAL + $NH4 + 0.2 * $POC;				

#		Use BRK and TIR process IDs for alternate PMC calculations
		if ( $processID eq "BRK" ) {
			$PMC = $PM10BRAKE - $PM25BRAKE;
		}
		elsif ( $processID eq "TIR" ) {
			$PMC = $PM10TIRE - $PM25TIRE;
		}
		else {
			$PMC = ($Ratio - 1.0) * ($PMFINE + $PM25EC + $POC + $PM25SO4 + $PNO3);
		}

        $pm_array[0] = $PNO3;
        $pm_array[1] = $METAL;
        $pm_array[2] = $NH4;
        $pm_array[3] = $POC;	
        $pm_array[4] = $PMFINE;		
        $pm_array[5] = $PMC;

}  # end Calc_PMs

#  -- map the MOVES pollutantID to SMOKE output short name ====================
sub INIT_SmokePolls
{
		$pollSmoke{1} = "THC";
		$pollSmoke{2} = "CO";
		$pollSmoke{3} = "NOX";
		$pollSmoke{5} = "CH4";
		$pollSmoke{6} = "N2O";
		$pollSmoke{20} = "BENZENE";
		$pollSmoke{21} = "ETOH";
		$pollSmoke{22} = "MTBE";
#		$pollSmoke{23} = "NAPHTH";
		$pollSmoke{24} = "BUTADIE";
		$pollSmoke{25} = "FORMALD";
		$pollSmoke{26} = "ACETALD";
		$pollSmoke{27} = "ACROLEI";
		$pollSmoke{30} = "NH3";
		$pollSmoke{31} = "SO2";
		$pollSmoke{32} = "NO";
		$pollSmoke{33} = "NO2";
		$pollSmoke{34} = "HONO";
		$pollSmoke{40} = "TRMEPN224";
		$pollSmoke{41} = "ETHYLBENZ";
		$pollSmoke{42} = "HEXANE";
		$pollSmoke{43} = "PROPIONAL";
		$pollSmoke{44} = "STYRENE";
		$pollSmoke{45} = "TOLUENE";
		$pollSmoke{46} = "XYLS";
		$pollSmoke{60} = "HG";
		$pollSmoke{61} = "HGIIGAS";
		$pollSmoke{62} = "PHGI";
		$pollSmoke{79} = "NMHC";
		$pollSmoke{80} = "NMOG";
		$pollSmoke{86} = "TOG";
		$pollSmoke{87} = "VOC_INV";
		$pollSmoke{90} = "ATCO2";
		$pollSmoke{91} = "TOTENRGYC";
#		$pollSmoke{92} = "PETROENRGYC";
#		$pollSmoke{93} = "FOSFUEL";
#		$pollSmoke{98} = "CO2EQUIVALENT";
		$pollSmoke{100} = "PM10OM";
		$pollSmoke{101} = "PM10OC";
		$pollSmoke{102} = "PM10EC";
		$pollSmoke{105} = "PM10SO4";
		$pollSmoke{106} = "PM10BRAKE";
		$pollSmoke{107} = "PM10TIRE";
		$pollSmoke{110} = "PM25OM";
		$pollSmoke{111} = "PM25OC";
		$pollSmoke{112} = "PEC";
		$pollSmoke{115} = "PSO4";
		$pollSmoke{116} = "PM25BRAKE";
		$pollSmoke{117} = "PM25TIRE";
		$pollSmoke{9118} = "PNO3";
		$pollSmoke{9119} = "METAL";
		$pollSmoke{9120} = "NH4";
		$pollSmoke{9121} = "POC";
		$pollSmoke{9122} = "PMFINE";
		$pollSmoke{9123} = "PMC";
#		$pollSmoke{9124} = "NO2"; # 30Mar2012: no longer needed, NO2 from pollutantID 33 is passed through directly
#		$pollSmoke{9125} = "HONO"; # 30Mar2012: no longer needed, NO2 from pollutantID 33 is passed through directly
}  # end INIT_SmokePolls

#  -- map the MOVES processID to SMOKE output process name ====================
sub INIT_SmokeProcess
{
		$procSmoke{1}  = "EXR";
		$procSmoke{2}  = "EXS";
		$procSmoke{9}  = "BRK";
		$procSmoke{10} = "TIR";
		$procSmoke{11} = "EPM";
		$procSmoke{12} = "EFV";
		$procSmoke{13} = "EFL";
		$procSmoke{15} = "CXR";
		$procSmoke{16} = "CXS";
		$procSmoke{17} = "CEI";
		$procSmoke{18} = "RFV";
		$procSmoke{19} = "RFS";
		$procSmoke{90} = "EXT";
}  # end INIT_SmokeProcess


sub trim
{
    my $s = shift;
    # remove leading spaces
    $s =~ s/^\s+//;
    # remove trailing spaces
    $s =~ s/\s+$//;
    # remove leading tabs
    $s =~ s/^\t+//;
    # remove trailing tabs
    $s =~ s/\t+$//;
    return $s; 
}

sub replace_slash
{
   $tmpstr = "";
   $len = length ($outDir);
   for($i=0;$i<=$len;++$i)
   {
	if ( substr($outDir,$i,1) eq "\\" ) {
		$tmpstr .= "/";
	}
	else {
		$tmpstr .= substr($outDir,$i,1)
	}
   }
   $outDir = $tmpstr;
#qaprintf "outDir is \n";
#qaprintf "%s\n",$outDir;
}
