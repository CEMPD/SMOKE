#!/usr/bin/perl
#
# Filename   : moves2smkEF_v0.1.pl
# Author     : Michele Jimenez, ENVIRON International Corp.
# Version    : 0.1
# Description: Generate SMOKE input Emission Factor Lookup Tables
#            : from MOVES2010 MySQL tables
#
#  Usage: moves2smkEF_v0.1.pl InputDBlist OutputPath(optional)\n";
#  		where
#  		InputDBlist - List of MySQL database names to process (generated by runspec_generator_v0.1.pl
#                             MOVES preprocessor)
#  		OutputPath - optional, if specified it overrides the output path specified in InputDBlist
#
#  Update log: 
#  MJimenez 16 june 2010 v0.13 Corrected typo in ratepervehicle PM calculation INSERT
#  UNC      ?? june 2010 v0.12 Generate additional output file of list of output SMOKE files and generate separate
#                              output emission factor tables by representative county and month.
#  MJimenez 05 july 2010 v0.13 implemented PM calculation correction outlined in 
#                              MOVES2010 PM25 Onroad Speciation method_4jun2010.doc
#
#  UNC      18 Aug  2010 v0.20 Removed SCC mapping part. MOVES2010a has an option to output SCC.
#                              Updated script to handle the MOVES2010a output tables with SCC
#
#  <ASSUMPTION> are demarcated within the code
#  <HARDCODE>  are demarcated within the code
#======================================================================================================================
#	<ASSUMPTION> - user has read/write/delete/create table and schema rights in mySQL
#======================================================================================================================
#= MOVES to SMOKE Emission Factor Tables - a MOVES preprocessor utility
#=
#= Copyright (C) 2010 ENVIRON International Corporation
#=
#= The Runspec Generator is free software; you can redistribute it 
#= and/or modify it under the terms of the GNU General Public License
#= as published by the Free Software Foundation; either version 3
#= of the License, or (at your option) any later version.
#=
#= This utility is distributed in the hope that it will be useful,
#= but WITHOUT ANY WARRANTY; without even the implied warranty of
#= MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#= GNU General Public License for more details.
#=
#= You should have received a copy of the GNU General Public License
#= along with this program.  If not, see <http://www.gnu.org/licenses/>.
#=======================================================================

# --- variable declarations
use strict;
use DBI;
use FileHandle;

my ($dbFile, $outDir, $outfile, $listfile, $hostname,$host, $userid, $passwd, $lt);
my ($db, $connectionInfo, $dbh, $sql, $sth, $sth2, $sql2, $sql3, $sqlX, $sqlX_2, $sthx, @data, @dataX);
my ($inputDB);
my ($debug,$len,$tmpstr);

# for PM calculations
my ($MOVESScenarioID, $yearID, $monthID, $dayID, $hourID, $FIPS, $pollID);
my ($SCCsmoke, $processID, $avgSpdBin, $temp, $relHum, $PM25OM, $PM25EC, $PM25SO4);
my ($PNO3, $METAL, $NH4, $POC, $PMFINE, $PMC);
my ($FEC, $FNO3, $FMETAL, $Ratio, @pm_array, @pm_newIDs,$i, $sum);

# for output files
my ($csv_terminated, $csv_separator, $csv_enclosed, $csv_escaped,$fldlist,$fldstr);

my (%pollSmoke, %procSmoke);
INIT_SmokePolls();
INIT_SmokeProcess();
#================================================================================================

# --- check arguments

($#ARGV >= 0) or die "Usage: moves_to_smoke_EFtables.pl InputDBlist OutputPath(optional)\n";
$dbFile = $ARGV[0];
$outDir = "";
$outDir = $ARGV[1] if ($#ARGV == 1);

#================================================================================================
#  --- initialize ---
#
#  new PM2.5 speciated output pollutant IDs
#  <HARDCODE> - dummy integer pollutant IDs for PM2.5 speciation requirement
$pm_newIDs[0] = 9118;  #PNO3
$pm_newIDs[1] = 9119;  #METAL
$pm_newIDs[2] = 9120;  #NH4
$pm_newIDs[3] = 9121;  #POC
$pm_newIDs[4] = 9122;  #PMFINE
$pm_newIDs[5] = 9123;  #PMC

#  --- turn debug off, deletes all temporary tables (default)
$debug = 0;

#  --- for output csv formatted files
$csv_terminated = "\n";
$csv_separator = ",";
$csv_enclosed = '"';
$csv_escaped = "\\";

#================================================================================================

# --- open file of list of DBs to process, generated from the MOVES Driver Script preprocessor 
# <ASSUMPTION> - userid and password are null

open(DBLISTFILE, "$dbFile") or die "Unable to open input file of database names: $dbFile\n";

$_ = <DBLISTFILE>;
chomp($_);
if (uc trim($_) eq "DEBUG")  
{
	$debug = 1;
	$hostname = <DBLISTFILE>;
	chomp($hostname);
}
else
{
	$hostname = $_;
}

$_ = <DBLISTFILE>;
chomp($_);
$outDir = $_ if ($outDir == "");
replace_slash();

# --- database information
$host=$hostname;
$userid="";
$passwd="";

#================================================================================================
my ($count, $calYear, $fips_use, $MOVES_DB_used);
$count = 1;
while (<DBLISTFILE>)
{
#	--- make connection to database

	$db=$_;      
	chomp($db);
	$connectionInfo="dbi:mysql:$db;$host";

	$dbh = DBI->connect($connectionInfo,$userid,$passwd) or die "Database connection not made\n";

	$lt = localtime;
	printf "\n%s Processing database %s...\n\n",$lt,$db;

#	-- get a corresponding input database name 
	$sql = " SELECT defaultDatabaseUsed, domainCountyID, domainDatabaseName from movesrun limit 1";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	if (@data = $sth->fetchrow_array())
	{
		$MOVES_DB_used = $data[0];
		$fips_use = $data[1];
		$inputDB = $data[2];
		$calYear = substr($data[2],9,4);
	}
#                                                          ========================================
#  -- Set up tables for all runs --- create a new schema MOVESPostProc to store a set of tables ---
#  --                                that will be referenced by all DBs in batch file           ---
#  --                                These are a pared down version of the default MOVES DB     ---
	if ( $count == 1 ) {

		++$count;

		$sql = "DROP DATABASE IF EXISTS MOVESPostProc";
		$sth = $dbh->prepare($sql);
		$sth->execute();

		$sql = "CREATE SCHEMA MOVESPostProc";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		$sql = "CREATE TABLE MOVESPostProc.smokeProcess \
			SELECT processID, processName, shortName AS smokeProcID \
			FROM $MOVES_DB_used.emissionprocess";
		$sth = $dbh->prepare($sql);
		$sth->execute() or die "Error executing query: " . $sth->errstr;

		foreach $i (sort(keys(%procSmoke)))
		{
			$sql = "UPDATE MOVESPostProc.smokeProcess";
			$sql = $sql . " SET smokeProcID = '" . $procSmoke{$i} . "'";
			$sql = $sql . " WHERE processID = '" . $i . "'";

			$sth = $dbh->prepare($sql);
			$sth->execute() or die "Error executing query: " . $sth->errstr;
		}
	        $sql = "CREATE INDEX tmp_pid_idx1 ON MOVESPostProc.smokeProcess (processID);";
		$sth = $dbh->prepare($sql);
		$sth->execute();

		$lt = localtime;
		printf "  - Completed MOVESPostProc tables at %s\n",$lt;

	}  # end if, generate global tables in MOVESPostProc schema   ===========================

#================================================================================================
#	============= rate per distance table postprocessing =================================== RD
#================================================================================================

	$sql = "DROP TABLE IF EXISTS \
			RDpreX, \
			rateperdistance_smoke, \
			RVpreX, \
			ratepervehicle_smoke, \
			RPpreX, \
			rateperprofile_smoke, \
                        rateperdistance_short, \
                        ratepervehicle_short ";

	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - Completed drop tables at %s\n",$lt;

#       ==================================================================================
#	-- now lets get on to the rate per distance table --
#       ==================================================================================

	my ($maxHr, $lastTemp, $recNo, $whereClause);

#       --- we need to drop the hours with duplicate temperatures.  determine the condition
#       --- based on the distinct hours and temperatures
#       <ASSUMPTION> - the RD table has a different temperature bin for each hour, from min t at hour 0
#                      to max t.  If more than 24 temp bins then multiple MOVES runs will be made
	$sql = "SELECT DISTINCT hourID, temperature \
		FROM rateperdistance \
		WHERE SUBSTR(MOVESScenarioID,1,2) = 'RD' \
		ORDER BY temperature, hourID";
        $sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	
	$recNo = 0;
	$lastTemp = -999.;
	while (@data = $sth->fetchrow_array())
	{
		++$recNo;
		if ( $data[1] != $lastTemp ) 
		{
			$lastTemp = $data[1];
			$maxHr = $data[0];
		}
	}

	if ( $recNo == 24 ) 
	{
		$whereClause = " AND hourID <= " . $maxHr;
	}
	else
	{
		$whereClause = " AND temperature < " . $lastTemp;
		$whereClause = $whereClause . " OR (temperature = " . $lastTemp . " AND hourID = " . $maxHr . " )";
	}
	
	printf "\n  Starting rate per distance processing...\n";

        $sql = "CREATE TABLE rateperdistance_short \
                SELECT MOVESScenarioID, yearID, monthID, pollutantID, processID, SCC, \
                  avgSpeedBinID, temperature, relHumidity, CAST((SUBSTR(linkID,1,5)) AS UNSIGNED INTEGER) AS FIPS, ratePerDistance \
                FROM rateperdistance WHERE SUBSTR(MOVESScenarioID,1,2) = 'RD'";
	$sql = $sql . $whereClause;
        $sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$lt = localtime;
	printf "  - Created rateperdistance_short at %s\n",$lt;

	$sql = "CREATE TABLE RDpreX \
		SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.FIPS, r.pollutantID, \
			p.smokeProcID, r.avgSpeedBinID, r.temperature, r.relHumidity, \
			CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
			r.ratePerDistance AS EFfinal \
		FROM rateperdistance_short r \
                     JOIN MOVESPostProc.smokeProcess p ON  r.processID = p.processID";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - Completed RDpreX at %s\n",$lt;

#	Generate the PM pollutants.  =========================================================
#	<HARDCODE> (see subroutine Calc_PMs)
#	The PM calculations are taken from "Interim Approach to develop CMAQ PM2.5 species
#	from Partially-speciated MOVES2010 EXHAUST PM2.5" by Madeleine Strum, EPA 16 Mar 2010
#
#	First do a cross tab to get the PM pollutants of interest,
#	then compute new pollutants, and finally insert additional PM records into RD table
#	=======================================================================================

	$sql = "SELECT rd.MOVESScenarioID, rd.yearID, rd.monthID, \
			rd.FIPS, rd.SCCsmoke, rd.smokeProcID, rd.avgSpeedBinID, rd.temperature, rd.relHumidity, \
			SUM(CASE PollutantID WHEN 111 THEN EFfinal ELSE 0 END) AS PM25OM, \
			SUM(CASE PollutantID WHEN 112 THEN EFfinal ELSE 0 END) AS PM25EC, \
			SUM(CASE PollutantID WHEN 115 THEN EFfinal ELSE 0 END) AS PM25SO4 \
		FROM RDpreX rd \
		WHERE pollutantID IN (111, 112, 115) \
			AND smokeProcID IN ('EXR', 'EXS', 'CXR', 'CXS', 'CEI', 'EXT') \
		GROUP BY MOVESScenarioID, yearID, monthID, \
				FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	while (@data = $sth->fetchrow_array())
	{
		$MOVESScenarioID = $data[0];
		$yearID 	= $data[1];
		$monthID	= $data[2];
		$FIPS		= $data[3];
		$SCCsmoke	= $data[4];
		$processID	= $data[5];
		$avgSpdBin	= $data[6];
		$temp		= $data[7];
		$relHum		= $data[8];
		$PM25OM		= $data[9];
		$PM25EC		= $data[10];
		$PM25SO4	= $data[11];

		Calc_PMs();

		for($i=0;$i<=5;++$i)
		{
			$sqlX = "INSERT INTO RDpreX \
					(MOVESScenarioID, yearID, monthID, FIPS, pollutantID, SCCsmoke, smokeProcID, \
					avgSpeedBinID, temperature, relHumidity, EFfinal) \
				VALUES ('$MOVESScenarioID', $yearID, $monthID, $FIPS, $pm_newIDs[$i], '$SCCsmoke', '$processID', \
					$avgSpdBin, $temp, $relHum, $pm_array[$i])";
	
			$sthx = $dbh->prepare($sqlX);
			$sthx->execute() or die "Error executing query: " . $sthx->errstr;
		}  # end of insert for loop

	} #  end of PM data record processing  ========================================
	$lt = localtime;
	printf "  - Completed PM calculations at %s\n",$lt;

#	--do final cross tab query; all pollutants output on a single record =============
#	==================================================================================

	$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
		FROM RDpreX \
		GROUP BY pollutantID";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$sqlX = "CREATE TABLE rateperdistance_smoke \
		SELECT MOVESScenarioID, yearID, monthID, \
			FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity";

	while  (@data = $sth->fetchrow_array())
	{		
		$pollID = $data[0];
		$sum	= $data[1];

		$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
	}

	$sqlX_2 = " FROM RDpreX \
		GROUP BY MOVESScenarioID, yearID, monthID, \
			FIPS, SCCsmoke, smokeProcID, avgSpeedBinID, temperature, relHumidity \
		ORDER BY temperature ASC, SCCsmoke ASC, \
			field(smokeProcID,'EXR','CXR','EVP','EFV','EFL','BRK','TIR'), avgSpeedBinID ASC";
	$sqlX = $sqlX . $sqlX_2;
	$sthx = $dbh->prepare($sqlX);
	$sthx->execute() or die "Error executing query: " . $sthx->errstr;
        $lt = localtime;
        printf "  - Completed rateperdistance_SMOKE at %s\n",$lt;

#	--- generate output files for each reference county and fuel month
        $listfile = $outDir . "mrclist.rateperdistance.lst";
        unlink($listfile);
        open(LISTFILE, ">$listfile") or die "Unable to open output list file: $listfile\n";

	$sqlX = "SELECT DISTINCT FIPS, monthID \
		FROM rateperdistance_smoke \
		ORDER BY FIPS, monthID";
        $sthx = $dbh->prepare($sqlX);
        $sthx->execute() or die "Error executing query: " . $sthx->errstr;
        
        while (@dataX = $sthx->fetchrow_array())
        {
        
#	        --- generate the header line for output table ---
                $sql = "SHOW COLUMNS FROM rateperdistance_smoke";
                $sth = $dbh->prepare($sql);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
        
                $fldstr = "";
                while  (@data = $sth->fetchrow_array())
                {
                        $fldlist = "'" . $data[0] . "'" . $csv_separator;
                        $fldstr .= $fldlist;
                }
                $sql2 = substr($fldstr,0,-1);
                $sql2 .= $csv_terminated;
        
                $outfile = "rateperdistance_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
                unlink($outDir . $outfile);
                $sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM rateperdistance_smoke \
                        WHERE FIPS = '" . $dataX[0] . "' \
                        AND monthID = '" . $dataX[1] . "' \
                        INTO OUTFILE '" . $outDir . $outfile . "' \
                        FIELDS TERMINATED BY ','  LINES TERMINATED BY '\n'";
        
                $sth = $dbh->prepare($sql3);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
                
                print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
        }
        close(LISTFILE);
        $lt = localtime;
        printf "  - Completed rateperdistance_SMOKE export at %s\n",$lt;

#================================================================================================
#	============= rate per vehcile table postprocessing =================================== RV
#================================================================================================
	printf "\n  Starting rate per vehicle processing...\n";

        $sql = "CREATE TABLE ratepervehicle_short \
                SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.dayID, r.hourID, r.zoneID, r.pollutantID, \
                       r.processID, r.temperature, r.SCC, r.ratePerVehicle \
                FROM ratepervehicle r \
                WHERE substr(r.MOVESScenarioID,1,2) = 'RV';";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - created ratepervehicle_short at %s\n",$lt;

	$sql = "CREATE TABLE RVpreX \
		SELECT r.MOVESScenarioID, r.yearID, r.monthID, r.dayID, r.hourID, SUBSTR(r.zoneID,1,5) as FIPS, r.pollutantID, \
			p.smokeProcID, r.temperature, CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
			r.ratePerVehicle AS EFfinal \
		FROM ratepervehicle_short r \
                     JOIN MOVESPostProc.smokeProcess p ON r.processID = p.processID";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - Completed RVpreX at %s\n",$lt;

#	Generate the PM pollutants.  =========================================================
#	<HARDCODE> (see subroutine Calc_PMs)
#	The PM calculations. First do a cross tab to get the PM pollutants of interest,
#	then compute new pollutants, and finally insert additional PM records into RV table
#	=======================================================================================

	$sql = "SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, \
			FIPS, SCCsmoke, smokeProcID, temperature, \
			SUM(CASE PollutantID WHEN 111 THEN EFfinal ELSE 0 END) AS PM25OM, \
			SUM(CASE PollutantID WHEN 112 THEN EFfinal ELSE 0 END) AS PM25EC, \
			SUM(CASE PollutantID WHEN 115 THEN EFfinal ELSE 0 END) AS PM25SO4 \
		FROM RVpreX \
		WHERE pollutantID IN (111, 112, 115) \
			AND smokeProcID IN ('EXR', 'EXS', 'CXR', 'CXS', 'CEI', 'EXT') \
		GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, \
				FIPS, SCCsmoke, smokeProcID, temperature";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	while (@data = $sth->fetchrow_array())
	{
		$MOVESScenarioID = $data[0];
		$yearID 	= $data[1];
		$monthID	= $data[2];
		$dayID		= $data[3];
		$hourID		= $data[4];
		$FIPS		= $data[5];
		$SCCsmoke	= $data[6];
		$processID	= $data[7];
		$temp		= $data[8];
		$PM25OM		= $data[9];
		$PM25EC		= $data[10];
		$PM25SO4	= $data[11];

		Calc_PMs();

		for($i=0;$i<=5;++$i)
		{
			$sql = "INSERT INTO RVpreX \
					(MOVESScenarioID, yearID, monthID, dayID, hourID, \
					FIPS, pollutantID, SCCsmoke, smokeProcID, temperature, EFfinal) \
				VALUES ('$MOVESScenarioID', $yearID, $monthID, $dayID, $hourID, \
                                        $FIPS, $pm_newIDs[$i], '$SCCsmoke', '$processID', $temp, $pm_array[$i])";
			$sth2 = $dbh->prepare($sql);
			$sth2->execute() or die "Error executing query: " . $sth2->errstr;
		}  # end of insert for loop

	} #  end of PM data record processing  ========================================
	$lt = localtime;
	printf "  - Completed PM calculations at %s\n",$lt;

#	--rate per vehicle -- do final cross tab query; all pollutants output on a single record =============
#	======================================================================================================

	$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
		FROM RVpreX \
		GROUP BY pollutantID";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$sqlX = "CREATE TABLE ratepervehicle_smoke \
		SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature";

	while  (@data = $sth->fetchrow_array())
	{		
		$pollID = $data[0];
		$sum	= $data[1];

		$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
	}

	$sqlX = $sqlX . " FROM RVpreX \
		GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, FIPS, SCCsmoke, smokeProcID, temperature \
		ORDER BY temperature ASC, dayID ASC, SCCsmoke ASC, \
			field(smokeProcID,'EXS','CXS','EVP','EFV','EFL','CEI'), hourID ASC";
	$sth = $dbh->prepare($sqlX);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$lt = localtime;
	printf "  - Completed ratepervehicle_SMOKE at %s\n",$lt;

#	--- generate output files for each reference county and fuel month
        $listfile = $outDir . "mrclist.ratepervehicle.lst";
        unlink($listfile);
        open(LISTFILE, ">$listfile") or die "Unable to open output list file: $listfile\n";

	$sqlX = "SELECT DISTINCT FIPS, monthID \
		FROM ratepervehicle_smoke \
		ORDER BY FIPS, monthID";
        $sthx = $dbh->prepare($sqlX);
        $sthx->execute() or die "Error executing query: " . $sthx->errstr;
        
        while (@dataX = $sthx->fetchrow_array())
        {

#	        --- generate the header line for output table ---
                $sql = "SHOW COLUMNS FROM ratepervehicle_smoke";
                $sth = $dbh->prepare($sql);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
        
                $fldstr = "";
                while  (@data = $sth->fetchrow_array())
                {
                        $fldlist = "'" . $data[0] . "'" . $csv_separator;
                        $fldstr .= $fldlist;
                }
                $sql2 = substr($fldstr,0,-1);
                $sql2 .= $csv_terminated;
        
                $outfile = "ratepervehicle_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
                unlink($outDir . $outfile);
                $sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM ratepervehicle_smoke \
                        WHERE FIPS = '" . $dataX[0] . "' \
                        AND monthID = '" . $dataX[1] . "' \
                        INTO OUTFILE '" . $outDir . $outfile . "' \
                        FIELDS TERMINATED BY ','  LINES TERMINATED BY '\n'";
        
                $sth = $dbh->prepare($sql3);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
                
                print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
        }
        close(LISTFILE);
        $lt = localtime;
        printf "  - Completed ratepervehicle_SMOKE export at %s\n",$lt;

#================================================================================================
#	============= rate per profile table postprocessing =================================== RP
#================================================================================================
	printf "\n  Starting rate per profile processing...\n";

	$sql = "CREATE TABLE RPpreX \
		SELECT r.MOVESScenarioID, r.yearID, substr(r.temperatureProfileID,7,2) AS monthID, r.dayID, r.hourID, \
			substr(r.temperatureProfileID,1,5) AS countyID, r.pollutantID, \
			p.smokeProcID, r.temperature, CONCAT(SUBSTR(r.SCC,1,9),'0') AS SCCsmoke, \
			r.ratePerVehicle AS EFfinal \
		FROM rateperprofile r \
		     JOIN MOVESPostProc.smokeProcess p ON r.processID = p.processID \
		WHERE substr(r.MOVESScenarioID,1,2) = 'RP'";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
	$lt = localtime;
	printf "  - Completed RPpreX at %s\n",$lt;

#	-- Note - no PMs with rateperProfile records ---

#	--rate per profile -- do final cross tab query; all pollutants output on a single record =============
#	======================================================================================================

	$sql = "SELECT pollutantID, sum(EFfinal) AS emsTotal \
		FROM RPpreX \
		GROUP BY pollutantID";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$sqlX = "CREATE TABLE rateperprofile_smoke \
		SELECT MOVESScenarioID, yearID, monthID, dayID, hourID, countyID, SCCsmoke, smokeProcID, temperature";

	while  (@data = $sth->fetchrow_array())
	{		
		$pollID = $data[0];
		$sum	= $data[1];

		$sqlX = $sqlX . ", SUM(CASE PollutantID WHEN " . $pollID . " THEN EFfinal ELSE 0 END) AS " . $pollSmoke{$pollID};
	}

	$sqlX = $sqlX . " FROM RPpreX \
		GROUP BY MOVESScenarioID, yearID, monthID, dayID, hourID, countyID, SCCsmoke, smokeProcID, temperature \
		ORDER BY MOVESScenarioID ASC, dayID ASC, SCCsmoke ASC, hourID, temperature"; 
	$sth = $dbh->prepare($sqlX);
	$sth->execute() or die "Error executing query: " . $sth->errstr;

	$lt = localtime;
	printf "  - Completed rateperprofile_SMOKE at %s\n",$lt;

#	--- generate output files for each reference county and fuel month
        $listfile = $outDir . "mrclist.rateperprofile.lst";
        unlink($listfile);
        open(LISTFILE, ">$listfile") or die "Unable to open output list file: $listfile\n";

	$sqlX = "SELECT DISTINCT countyID, monthID \
		FROM rateperprofile_smoke \
		ORDER BY countyID, monthID";
        $sthx = $dbh->prepare($sqlX);
        $sthx->execute() or die "Error executing query: " . $sthx->errstr;
        
        while (@dataX = $sthx->fetchrow_array())
        {

#	        --- generate the header line for output table ---
                $sql = "SHOW COLUMNS FROM rateperprofile_smoke";
                $sth = $dbh->prepare($sql);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
        
                $fldstr = "";
                while  (@data = $sth->fetchrow_array())
                {
                        $fldlist = "'" . $data[0] . "'" . $csv_separator;
                        $fldstr .= $fldlist;
                }
                $sql2 = substr($fldstr,0,-1);
                $sql2 .= $csv_terminated;
        
                $outfile = "rateperprofile_smoke_" . $db . "_" . $dataX[0] . "_" . $dataX[1] . ".csv";
                unlink($outDir . $outfile);
                $sql3 = "SELECT " . $sql2 . " UNION SELECT * FROM rateperprofile_smoke \
                        WHERE countyID = '" . $dataX[0] . "' \
                        AND monthID = '" . $dataX[1] . "' \
                        INTO OUTFILE '" . $outDir . $outfile . "' \
                        FIELDS TERMINATED BY ','  LINES TERMINATED BY '\n'";
        
                $sth = $dbh->prepare($sql3);
                $sth->execute() or die "Error executing query: " . $sth->errstr;
                
                print LISTFILE $dataX[0] . " " . $dataX[1] . " " . $outfile . "\n";
        }
        close(LISTFILE);
        $lt = localtime;
        printf "  - Completed rateperprofile_SMOKE export at %s\n",$lt;

#	======================================================================================================
#  --- delete all of the temporary tables in order to free up disk space ---
if ( $debug == 0 )
{
	$sql = "DROP TABLE IF EXISTS \
		RDpreX, \
		RVpreX, \
		RPpreX, \
		rateperdistance_short, \
		ratepervehicle_short ";
	$sth = $dbh->prepare($sql);
	$sth->execute() or die "Error executing query: " . $sth->errstr;
}

}  # end of processing ___ while, list of dbs

#================================================================================================
#  Subroutines
#================================================================================================

#  -- the PM calculation, similar for RD and RV tables ====================
#<HARDCODE> 	The PM calculations are taken from "Interim Approach to develop CMAQ PM2.5 species
#<HARDCODE>     from Partially-speciated MOVES2010 EXHAUST PM2.5" by Madeleine Strum, EPA 16 Mar 2010
#<HARDCODE>	07July2010 update per MStrum revisions dated June 4,2010
sub Calc_PMs
{
my ($PEC_Tadj, $maxtemp);
$maxtemp = 72.0;

		if (substr($SCCsmoke,0,4) eq "2201" ){
			$FEC = 20.80113619;
			$FNO3 = 0.1015;
			$FMETAL = 2.2256;
			$Ratio = 1.086;
		}
		elsif (substr($SCCsmoke,0,6) eq "223007") {
			$FEC = 77.1241;
			$FNO3 = 0.1141;
			$FMETAL = 0.2757;
			$Ratio = 1.0309;
		}
		elsif (substr($SCCsmoke,0,4) eq "2230") {
			$FEC = 57.48051203;
			$FNO3 = 0.23;
			$FMETAL = 0.6513;
			$Ratio = 1.0309;
		}
		else 	{
			die "ERROR:  No match for SMOKE SCC code PM conversion factors \n";
		}

#		MOVES cold temperature adjustment to gas vehicles
		$PEC_Tadj = 1.0;
		if (substr($SCCsmoke,0,4) eq "2201" )
                {
			if ($temp < $maxtemp )
			{

				if ( $processID eq "EXR" || $processID eq "CXR" ) {
					$PEC_Tadj = 9.871 * exp(-0.0318 * $temp);
				}
				else
				{
					$PEC_Tadj = 28.039 * exp(-0.0463 * $temp);
				}
			}
		}

		$PNO3 = ($PM25EC/$PEC_Tadj) * $FNO3 / $FEC;					

		$METAL = ($PM25EC/$PEC_Tadj) * $FMETAL / $FEC;					

		$NH4 = ($PNO3/62.0049 + 2 * $PM25SO4/96.0576) * 18.0383;	

		$POC = 5/6 * ($PM25OM - $METAL - $NH4 - $PNO3);		

		$PMFINE = $METAL + $NH4 + 0.2 * $POC;				

		$PMC = ($Ratio - 1.0) * ($PMFINE + $PM25EC + $POC + $PM25SO4 + $PNO3);	

                $pm_array[0] = $PNO3;
                $pm_array[1] = $METAL;
                $pm_array[2] = $NH4;
                $pm_array[3] = $POC;	
                $pm_array[4] = $PMFINE;		
                $pm_array[5] = $PMC;

}  # end Calc_PMs

#  -- map the MOVES pollutantID to SMOKE output short name ====================
sub INIT_SmokePolls
{
		$pollSmoke{1} = "THC";
		$pollSmoke{2} = "CO";
		$pollSmoke{3} = "NOX";
		$pollSmoke{5} = "CH4";
		$pollSmoke{6} = "N2O";
		$pollSmoke{20} = "BENZENE";
		$pollSmoke{21} = "ETHANOL";
		$pollSmoke{22} = "MTBE";
		$pollSmoke{23} = "NAPHTH";
		$pollSmoke{24} = "BUTADIE";
		$pollSmoke{25} = "FORMALD";
		$pollSmoke{26} = "ACETALD";
		$pollSmoke{27} = "ACROLEI";
		$pollSmoke{30} = "NH3";
		$pollSmoke{31} = "SO2";
		$pollSmoke{32} = "NO";
		$pollSmoke{33} = "NO2";
		$pollSmoke{79} = "NMHC";
		$pollSmoke{80} = "NMOG";
		$pollSmoke{86} = "TOG";
		$pollSmoke{87} = "VOC";
		$pollSmoke{90} = "ATCO2";
		$pollSmoke{91} = "TOTENRGYC";
		$pollSmoke{92} = "PETROENRGYC";
		$pollSmoke{93} = "FOSFUEL";
		$pollSmoke{98} = "CO2EQUIVALENT";
		$pollSmoke{100} = "PM10OM";
		$pollSmoke{101} = "PM10OC";
		$pollSmoke{102} = "PM10EC";
		$pollSmoke{105} = "PM10SO4";
		$pollSmoke{106} = "PM10BRAKE";
		$pollSmoke{107} = "PM10TIRE";
		$pollSmoke{110} = "PM25OM";
		$pollSmoke{111} = "PM25OC";
		$pollSmoke{112} = "PM25EC";
		$pollSmoke{115} = "PM25SO4";
		$pollSmoke{116} = "PM25BRAKE";
		$pollSmoke{117} = "PM25TIRE";
		$pollSmoke{9118} = "PNO3";
		$pollSmoke{9119} = "METAL";
		$pollSmoke{9120} = "NH4";
		$pollSmoke{9121} = "POC";
		$pollSmoke{9122} = "PMFINE";
		$pollSmoke{9123} = "PMC";
}  # end INIT_SmokePolls

#  -- map the MOVES processID to SMOKE output process name ====================
sub INIT_SmokeProcess
{
		$procSmoke{1}  = "EXR";
		$procSmoke{2}  = "EXS";
		$procSmoke{9}  = "BRK";
		$procSmoke{10} = "TIR";
		$procSmoke{11} = "EVP";
		$procSmoke{12} = "EFV";
		$procSmoke{13} = "EFL";
		$procSmoke{15} = "CXR";
		$procSmoke{16} = "CXS";
		$procSmoke{17} = "CEI";
		$procSmoke{18} = "RFV";
		$procSmoke{19} = "RFS";
		$procSmoke{90} = "EXT";
}  # end INIT_SmokeProcess


sub trim
{
    my $s = shift;
    # remove leading spaces
    $s =~ s/^\s+//;
    # remove trailing spaces
    $s =~ s/\s+$//;
    # remove leading tabs
    $s =~ s/^\t+//;
    # remove trailing tabs
    $s =~ s/\t+$//;
    return $s; 
}

sub replace_slash
{
   $tmpstr = "";
   $len = length ($outDir);
   for($i=0;$i<=$len;++$i)
   {
	if ( substr($outDir,$i,1) eq "\\" ) {
		$tmpstr .= "/";
	}
	else {
		$tmpstr .= substr($outDir,$i,1)
	}
   }
   $outDir = $tmpstr;
#qaprintf "outDir is \n";
#qaprintf "%s\n",$outDir;
}
