C Version @(#)$Id$ $Source$ $Date$ 

      SUBROUTINE GETVER(FLGERR,*)
C
C  GETVER reads in and validates the Control Section flags via the vertical
C  input mode: one flag per input line in I1 format.
C
C  Called by CONSEC.
C
C  Calls QUITER.
C
C  Input on call:
C
C    common blocks:
C    /FLAGS1/ PROMPT
C    /IOUCOM/ IOUGEN,IOUASK
C    /NAMES1/ NAMFLG
C    /STRING/ COLON
C
C  Output on return:
C
C    parameter list: FLGERR
C    common blocks:
C    /FLAGS1/ TAMFLG,SPDFLG,VMFLAG
C    /FLAGS2/ MYMRFG,NEWFLG,IMFLAG,ALHFLG,IMTIER
C    /FLAGS3/ ATPFLG,RLFLAG,LOCFLG,TEMFLG,OUTFMT
C    /FLAGS4/ PRTFLG,IDLFLG,NMHFLG,HCFLAG,COLDFG
C    /PRGCH2/ PRGFLG
C    /PRSCH2/ PRSFLG
C
C  Local variable dictionary:
C
C   Name   Type              Description
C  ------  ----  -------------------------------------------------------
C  USERFG   I    User's input of ATPFLG before it is broken down into
C                three flags: ATPFLG, PRSFLG, and PRGFLG.
C
C
C  Notes:
C
C  OUTFMT's range was extended up to 5 for Version 02's BYMY Tables option.
C  HCFLAG's range was extended up to 6 for MOBILE4.1.
C  COLDFG was added, but commented out for future use.
C  COLDFG is set in BD17.
C  Extended range of SPDFLG to 4 to read in TLVMT via WTLRUL for MOBILE4.1 D02
C  NEWFLG's range was extended up to 6 for MOBILE5.
C  OUTFMT's range was extended up to 6 for version 3 of MOBILE5 and allows the
C  spreadsheet readable/machine readable format option.
C  and it will be extended again to increase the range to 7 to allow a combo
C  spreadsheet/machine readable and by model year.
C  USERFG was added in MOBILE5 version 3 break up ATPFLG.
C
C
      CHARACTER*8 NAMFLG,NAMMMR
      CHARACTER*8 NAMRVP
      CHARACTER*4 NAMTEM
      CHARACTER*4 NOYES,COMMA,PERIOD
      CHARACTER*1 COLON
C
      INTEGER PROMPT,TAMFLG,SPDFLG,VMFLAG,OXYFLG,DSFLAG
      INTEGER ALHFLG,PRSFLG,PRGFLG,PRSPGM,PRSFQT
      INTEGER ATPFLG,TPDFLG,RLFLAG,TEMFLG,OUTFMT
      INTEGER PRTFLG,HCFLAG,COLDFG,PRGPGM,PRGFQT
C
      COMMON /FLAGS1/ PROMPT,TAMFLG,SPDFLG,VMFLAG,OXYFLG,DSFLAG
      COMMON /FLAGS2/ MYMRFG,NEWFLG,IMFLAG,ALHFLG,IMTIER
      COMMON /FLAGS3/ ATPFLG,TPDFLG,RLFLAG,LOCFLG,TEMFLG,OUTFMT
      COMMON /FLAGS4/ PRTFLG,IDLFLG,NMHFLG,HCFLAG,COLDFG
      COMMON /IOUCOM/ IOUIMD,IOUGEN,IOUREP,IOUERR,IOUASK
      COMMON /NAMES1/ NAMFLG(20),NAMMMR(2,3,8),NAMRVP(4),NAMTEM(2)
      COMMON /PRSCH2/ PRSPGM,PRSFQT,CRPRS,PRSFLG
      COMMON /PRGCH2/ PRGPGM,PRGFQT,CRPRG,PRGFLG
      COMMON /STRING/ NOYES(2),COMMA,PERIOD,COLON
C
      INTEGER FLGERR,USERFG
C
C  Do the in-range check immediately after flag read, since if in interactive
C  mode (PROMPT.EQ.2), user can then receive out-of-range message immediately
C  after entering an erroneous flag value.
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(1),COLON
  200 FORMAT('&','Enter',T7,A8,T14,A1)
      READ(IOUGEN,100,ERR=99,END=99) TAMFLG
  100 FORMAT(I1)
      IF(TAMFLG.LT.0.OR.TAMFLG.GT.2) CALL QUITER(1.,TAMFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(2),COLON
      READ(IOUGEN,100,ERR=99,END=99) SPDFLG
      IF(SPDFLG.LT.1.OR.SPDFLG.GT.4) CALL QUITER(2.,SPDFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(3),COLON
      READ(IOUGEN,100,ERR=99,END=99) VMFLAG
      IF(VMFLAG.LT.1.OR.VMFLAG.GT.3) CALL QUITER(3.,VMFLAG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(4),COLON
      READ(IOUGEN,100,ERR=99,END=99) MYMRFG
      IF(MYMRFG.LT.1.OR.MYMRFG.GT.4) CALL QUITER(4.,MYMRFG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(5),COLON
      READ(IOUGEN,100,ERR=99,END=99) NEWFLG
      IF(NEWFLG.LT.1.OR.NEWFLG.GT.6) CALL QUITER(5.,NEWFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(6),COLON
      READ(IOUGEN,100,ERR=99,END=99) IMFLAG
      IF(IMFLAG.LT.1.OR.IMFLAG.GT.5) CALL QUITER(6.,IMFLAG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(7),COLON
      READ(IOUGEN,100,ERR=99,END=99) ALHFLG
      IF(ALHFLG.LT.1.OR.ALHFLG.GT.3) CALL QUITER(7.,ALHFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(8),COLON
      READ(IOUGEN,100,ERR=99,END=99) USERFG
      IF(USERFG.LT.1.OR.USERFG.GT.8) CALL QUITER(8.,USERFG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(9),COLON
      READ(IOUGEN,100,ERR=99,END=99) RLFLAG
      IF(RLFLAG.LT.1.OR.RLFLAG.GT.5) CALL QUITER(9.,RLFLAG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(10),COLON
      READ(IOUGEN,100,ERR=99,END=99) LOCFLG
      IF(LOCFLG.LT.1.OR.LOCFLG.GT.2) CALL QUITER(10.,LOCFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(11),COLON
      READ(IOUGEN,100,ERR=99,END=99) TEMFLG
      IF(TEMFLG.LT.1.OR.TEMFLG.GT.2) CALL QUITER(11.,TEMFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(12),COLON
      READ(IOUGEN,100,ERR=99,END=99) OUTFMT
c
c  LMOS Modification 04/08/93
c  Allow a new output format 7
c
c      IF(OUTFMT.LT.1.OR.OUTFMT.GT.6) CALL QUITER(12.,OUTFMT,1,FLGERR)
      IF(OUTFMT.LT.1.OR.OUTFMT.GT.7) CALL QUITER(12.,OUTFMT,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(13),COLON
      READ(IOUGEN,100,ERR=99,END=99) PRTFLG
      IF(PRTFLG.LT.1.OR.PRTFLG.GT.4) CALL QUITER(13.,PRTFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(14),COLON
      READ(IOUGEN,100,ERR=99,END=99) IDLFLG
      IF(IDLFLG.LT.1.OR.IDLFLG.GT.2) CALL QUITER(14.,IDLFLG,1,FLGERR)
CC    IDLE FLAG FIX
      IDLFLG = 1
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(15),COLON
      READ(IOUGEN,100,ERR=99,END=99) NMHFLG
      IF(NMHFLG.LT.1.OR.NMHFLG.GT.5) CALL QUITER(15.,NMHFLG,1,FLGERR)
C
      IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(16),COLON
      READ(IOUGEN,100,ERR=99,END=99) HCFLAG
      IF(HCFLAG.LT.1.OR.HCFLAG.GT.6) CALL QUITER(16.,HCFLAG,1,FLGERR)
C
C     IF(PROMPT.EQ.2) WRITE(IOUASK,200)NAMFLG(17),COLON
C     READ(IOUGEN,100,ERR=99,END=99) COLDFG
C     IF(COLDFG.LT.1.OR.COLDFG.GT.3) CALL QUITER(17.,COLDFG,1,FLGERR)
C
      COLDFG=2
      IF(NEWFLG.GE.5) THEN
         COLDFG=1
         CALL QUITER(0.,0,135,INERR)
      ENDIF
C
C  Break USERFG into three flags
C
      ATPFLG=1
      PRSFLG=1
      PRGFLG=1
      GOTO (10,20,30,40,50,60,70,80) USERFG
   10 RETURN
C
   20        ATPFLG=2
      RETURN
C
   30        PRSFLG=2
      RETURN
C
   40        PRGFLG=2
      RETURN
C
   50        ATPFLG=2
             PRSFLG=2
      RETURN
C
   60        ATPFLG=2
             PRGFLG=2
      RETURN
C
   70        PRSFLG=2
             PRGFLG=2
      RETURN
C
   80        ATPFLG=2
             PRSFLG=2
             PRGFLG=2
      RETURN
C
C  Error or EOF on any attempted read => take alternate
C  return 1 => run aborts.
C
   99 CALL QUITER(0.,0,124,INERR)
C
      RETURN1
      END
